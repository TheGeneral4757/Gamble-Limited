{% extends "base.html" %}

{% block content %}
<div class="game-container plinko-game">
    <!-- Premium Game Header -->
    <div class="game-header">
        <div class="header-left">
            <a href="/" class="back-link">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                </svg>
                BACK
            </a>
        </div>
        <div class="header-center">
            <h2><span class="pulse-icon">üü£</span> PLINKO</h2>
        </div>
        <div class="header-right">
            <div class="balance-pill">
                <span class="label">CREDITS</span>
                <span class="value" id="game-balance">---</span>
            </div>
        </div>
    </div>

    <div class="game-area">
        <canvas id="plinko-board" width="800" height="600"></canvas>
        <div id="game-result" class="game-result"></div>
    </div>

    <!-- Rows Selector -->
    <div class="rows-selector">
        <label>ROWS: <span id="rows-value">16</span></label>
        <input type="range" id="rows-input" min="8" max="16" value="16" oninput="updateRows(this.value)">
    </div>

    <div class="game-controls">
        <div class="bet-controls">
            <label>BET AMOUNT</label>
            <div class="bet-input-wrapper">
                <button class="bet-adjust" onclick="adjustBet(-5); playSound('click');">-</button>
                <input type="number" id="bet-amount" value="{{ min_bet }}" min="{{ min_bet }}" max="{{ max_bet }}">
                <button class="bet-adjust" onclick="adjustBet(5); playSound('click');">+</button>
            </div>
            <div class="bet-quick-actions">
                <button class="quick-bet-btn" onclick="setBet({{ min_bet }})">MIN</button>
                <button class="quick-bet-btn" onclick="setBet({{ max_bet }})">MAX</button>
            </div>
        </div>
        <button class="action-btn drop-btn" id="drop-btn" onclick="dropBall()">
            <span class="btn-icon">‚¨áÔ∏è</span> DROP BALL
        </button>
    </div>

    <style>
        /* Quick Actions & Balance Pill (Copied from Slots) */
        .bet-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bet-quick-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .quick-bet-btn {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-dim);
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-bet-btn:hover {
            background: var(--primary);
            color: #000;
        }

        .balance-pill {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            min-width: 100px;
        }

        .balance-pill .label {
            font-size: 0.65rem;
            color: var(--text-dim);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .balance-pill .value {
            font-size: 1.1rem;
            color: var(--primary);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            line-height: 1;
        }
    </style>
</div>

<style>
    .plinko-game canvas {
        background: #0f172a;
        /* Dark blue/slate background */
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        margin: 20px auto;
        display: block;
        max-width: 100%;
        border: 2px solid #1e293b;
    }

    .rows-selector {
        margin: 20px auto;
        text-align: center;
        max-width: 300px;
        background: rgba(0, 0, 0, 0.2);
        padding: 15px;
        border-radius: 12px;
    }

    .rows-selector label {
        display: block;
        margin-bottom: 10px;
        font-weight: bold;
        color: var(--text-dim);
    }

    .rows-selector input[type="range"] {
        width: 100%;
        accent-color: var(--primary);
    }

    .game-result {
        text-align: center;
        width: 100%;
        height: 30px;
        font-weight: bold;
        font-size: 1.2rem;
        margin-top: 10px;
    }

    .drop-btn {
        background: linear-gradient(135deg, #E91E63, #C2185B);
    }

    .drop-btn:hover {
        box-shadow: 0 0 20px rgba(233, 30, 99, 0.4);
    }
</style>
{% endblock %}

{% block scripts %}
<!-- Use Matter.js for physics -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
    // Physics Engine Setup
    const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Events = Matter.Events;

    const engine = Engine.create();
    const world = engine.world;
    const canvas = document.getElementById('plinko-board');

    // Adjust canvas size
    // We'll keep fixed internal coordinate system 800x600 but scale visually via CSS if needed
    const render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
            width: 800,
            height: 600,
            wireframes: false,
            background: '#0f172a'
        }
    });

    // Game Config
    let rows = 16;
    const pegRadius = 5;
    const ballRadius = 6;
    let multipliers = []; // Holds UI objects for bucket multipliers

    // Init balance display & Canvas
    document.addEventListener('DOMContentLoaded', () => {
        const globalBal = document.getElementById('credits-balance');
        const gameBal = document.getElementById('game-balance');
        if (globalBal && gameBal) {
            gameBal.textContent = globalBal.textContent;
            const observer = new MutationObserver(() => { gameBal.textContent = globalBal.textContent; });
            observer.observe(globalBal, { childList: true, characterData: true, subtree: true });
        }
        initBoard();
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
    });

    function adjustBet(amount) {
        const input = document.getElementById('bet-amount');
        let val = parseInt(input.value || 0) + amount;
        setBet(val);
    }

    function setBet(amount) {
        const input = document.getElementById('bet-amount');
        const min = {{ min_bet }};
    const max = {{ max_bet }};
    input.value = Math.max(min, Math.min(max, amount));
    }

    function updateRows(val) {
        rows = parseInt(val);
        document.getElementById('rows-value').textContent = rows;
        initBoard();
    }

    function initBoard() {
        Composite.clear(world);
        engine.events = {}; // clear events

        // Dimensions
        const width = 800;
        const height = 600;
        const startY = 50;
        const gap = width / (rows + 3);

        // Pegs
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col <= row; col++) {
                const x = width / 2 - (row * gap / 2) + (col * gap);
                const y = startY + row * gap * 0.9;
                const peg = Bodies.circle(x, y, pegRadius, {
                    isStatic: true,
                    render: { fillStyle: '#ffffff' },
                    label: 'peg'
                });
                Composite.add(world, peg);
            }
        }

        // Buckets/Multipliers at bottom
        // Logic: N rows means N+1 buckets
        const bucketY = startY + rows * gap * 0.9 + 40;
        const bucketCount = rows + 1;

        // Visual multipliers just for display (Physics logic handles collisions differently if we want exact)
        // But for visual simulation, we just need walls between buckets
        for (let i = 0; i <= bucketCount; i++) {
            const x = width / 2 - (rows * gap / 2) + (i * gap) - (gap / 2);
            // Wall between buckets
            const wall = Bodies.rectangle(x, bucketY, 4, 60, {
                isStatic: true,
                render: { fillStyle: '#334155' },
                label: 'wall'
            });
            Composite.add(world, wall);
        }

        // Floor to stop infinite falling
        const ground = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
        Composite.add(world, ground);

        // Draw multipliers labels (Manual rendering hook)
        // We calculate multipliers roughly like: Center ~ 0.5x, Edges ~ high x
        // For simplicity, we assume backend calculates outcome, we just show generic
        Events.on(render, 'afterRender', function () {
            const ctx = render.context;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#fbbf24';
            ctx.textAlign = 'center';

            for (let i = 0; i < bucketCount; i++) {
                const x = width / 2 - (rows * gap / 2) + (i * gap);
                // Simple visual gradient from low (center) to high (edges)
                // This is just visual; backend determines payout
                let text = "x?";
                ctx.fillText(text, x, bucketY + 20);
            }
        });
    }

    async function dropBall() {
        const bet = parseFloat(document.getElementById('bet-amount').value);
        const dropBtn = document.getElementById('drop-btn');
        const resultEl = document.getElementById('game-result');

        dropBtn.disabled = true;
        resultEl.textContent = '';

        try {
            const response = await fetch('/api/games/plinko/drop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bet, rows })
            });

            const data = await response.json();

            if (!response.ok) {
                let msg = data.detail || 'Drop failed';
                if (Array.isArray(msg)) msg = msg.map(e => e.msg).join(', ');
                else if (typeof msg === 'object') msg = JSON.stringify(msg);
                throw new Error(msg);
            }

            // Spawn visual ball
            // We apply a tiny random offset to x to make physics look natural, 
            // but effectively backend result dictates balance. 
            // Since this is client-side Physics, result is unpredictable unless we force it.
            // For a fair "Provably Fair" we would animate pre-calculated path.
            // Here we just let it drop and stick the result at end.

            const ball = Bodies.circle(400 + (Math.random() - 0.5) * 2, 20, ballRadius, {
                restitution: 0.5,
                friction: 0.001,
                render: { fillStyle: '#e91e63' },
                label: 'ball'
            });
            Composite.add(world, ball);
            playSound('ballLand'); // Launch sound

            // Wait for ball to settle (approx 3-4s)
            await new Promise(r => setTimeout(r, 4000));

            // Show backend result
            if (data.payout > 0) {
                resultEl.innerHTML = `üéâ Win! ${data.multiplier}x = +${data.payout} CR`;
                resultEl.style.color = '#4CAF50';
                playSound('win');
            } else {
                resultEl.innerHTML = `Info: ${data.multiplier}x`;
                // Technically Plinko usually returns some small amount even on loss (e.g. 0.2x)
                if (data.multiplier < 1) playSound('lose');
                else playSound('win');
            }
            updateBalance(data.balance);

        } catch (error) {
            resultEl.textContent = '‚ùå ' + error.message;
            resultEl.style.color = '#f44336';
            playSound('error');
        }

        dropBtn.disabled = false;
        // Clean up balls after a while
        setTimeout(() => {
            const balls = Composite.allBodies(world).filter(b => b.label === 'ball');
            if (balls.length > 5) Composite.remove(world, balls[0]);
        }, 5000);
    }
</script>
{% endblock %}