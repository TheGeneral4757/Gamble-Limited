{% extends "base.html" %}

{% block content %}
<div class="game-container plinko-game">
    <div class="game-header">
        <h2>‚ö™ Plinko</h2>
        <a href="/" class="back-link">‚Üê Back to Lobby</a>
    </div>

    <div class="game-area plinko-area">
        <div class="plinko-wrapper">
            <div class="plinko-board" id="plinko-board">
                <div class="ball" id="plinko-ball">‚ö™</div>
            </div>
            <div class="multiplier-row" id="multiplier-slots"></div>
        </div>

        <div id="plinko-result" class="plinko-result"></div>
    </div>

    <div class="game-controls">
        <div class="bet-controls">
            <label>Bet Amount</label>
            <div class="bet-input-group">
                <button class="bet-adjust" onclick="adjustBet(-1); playSound('click');">-</button>
                <input type="number" id="bet-amount" value="{{ min_bet }}" min="{{ min_bet }}" max="{{ max_bet }}">
                <button class="bet-adjust" onclick="adjustBet(1); playSound('click');">+</button>
            </div>
        </div>

        <div class="rows-selector">
            <label>Rows:</label>
            <select id="rows-select" onchange="initBoard(); playSound('click');">
                <option value="8">8 Rows</option>
                <option value="12">12 Rows</option>
                <option value="16" selected>16 Rows</option>
            </select>
        </div>

        <button class="action-btn drop-btn" id="drop-btn" onclick="dropBall()">‚ö™ DROP</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const MULTIPLIERS = {
        16: [16, 9, 2, 1.4, 1.1, 0.5, 0.3, 0.5, 0.3, 0.5, 0.3, 0.5, 1.1, 1.4, 2, 9, 16],
        12: [10, 3, 1.5, 0.6, 0.4, 0.3, 0.3, 0.4, 0.6, 1.5, 3, 10],
        8: [5.6, 2.1, 0.5, 0.2, 0.2, 0.5, 2.1, 5.6]
    };

    let isDropping = false;

    function adjustBet(amount) {
        const input = document.getElementById('bet-amount');
        const newValue = Math.max({{ min_bet }}, Math.min({{ max_bet }}, parseInt(input.value || 0) + amount));
    input.value = newValue;
}

    function initBoard() {
        const rows = parseInt(document.getElementById('rows-select').value);
        const board = document.getElementById('plinko-board');
        const slotsContainer = document.getElementById('multiplier-slots');
        const multipliers = MULTIPLIERS[rows];

        // Clear and recreate board
        board.innerHTML = '<div class="ball" id="plinko-ball">‚ö™</div>';

        // Create peg rows
        for (let row = 0; row < rows; row++) {
            const pegRow = document.createElement('div');
            pegRow.className = 'peg-row';

            const pegsInRow = row + 3; // Start with 3 pegs, add 1 each row
            for (let peg = 0; peg < pegsInRow; peg++) {
                const pegEl = document.createElement('div');
                pegEl.className = 'peg';
                pegRow.appendChild(pegEl);
            }
            board.appendChild(pegRow);
        }

        // Create multiplier slots
        slotsContainer.innerHTML = '';
        multipliers.forEach((mult, i) => {
            const slot = document.createElement('div');
            let colorClass = 'low';
            if (mult >= 2) colorClass = 'high';
            else if (mult >= 1) colorClass = 'medium';
            slot.className = `mult-slot ${colorClass}`;
            slot.textContent = mult + 'x';
            slot.dataset.index = i;
            slotsContainer.appendChild(slot);
        });
    }

    async function dropBall() {
        if (isDropping) return;

        const bet = parseFloat(document.getElementById('bet-amount').value);
        const rows = parseInt(document.getElementById('rows-select').value);
        const dropBtn = document.getElementById('drop-btn');
        const resultEl = document.getElementById('plinko-result');
        const ball = document.getElementById('plinko-ball');
        const board = document.getElementById('plinko-board');

        isDropping = true;
        dropBtn.disabled = true;
        dropBtn.textContent = '‚ö™ DROPPING...';
        resultEl.textContent = '';
        resultEl.className = 'plinko-result';

        try {
            const response = await fetch('/api/games/plinko/drop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bet, rows })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.detail || 'Drop failed');
            }

            // Animate ball dropping
            ball.style.display = 'block';
            ball.style.opacity = '1';

            const boardRect = board.getBoundingClientRect();
            const boardWidth = boardRect.width;
            const boardHeight = boardRect.height;

            let posX = boardWidth / 2;
            ball.style.left = posX + 'px';
            ball.style.top = '10px';

            // Animate through path
            for (let i = 0; i < data.path.length; i++) {
                await new Promise(r => setTimeout(r, 60));

                const direction = data.path[i] === 'L' ? -1 : 1;
                posX += direction * (boardWidth / (rows * 2.5));

                const yProgress = ((i + 1) / data.path.length) * (boardHeight - 40);

                ball.style.left = Math.max(20, Math.min(boardWidth - 20, posX)) + 'px';
                ball.style.top = (10 + yProgress) + 'px';

                if (i % 2 === 0) playSound('ballDrop');
            }

            await new Promise(r => setTimeout(r, 200));
            playSound('ballLand');

            // Highlight winning slot
            const slots = document.querySelectorAll('.mult-slot');
            if (slots[data.final_slot]) {
                slots[data.final_slot].classList.add('winner');
            }

            // Show result
            if (data.big_win) {
                resultEl.textContent = `üéâ ${data.multiplier}x - BIG WIN! +${data.payout.toFixed(2)} CR`;
                resultEl.classList.add('win');
                playSound('bigWin');
            } else if (data.win) {
                resultEl.textContent = `‚úÖ ${data.multiplier}x - You win! +${data.payout.toFixed(2)} CR`;
                resultEl.classList.add('win');
                playSound('win');
            } else {
                resultEl.textContent = `${data.multiplier}x - Returned ${data.payout.toFixed(2)} CR (${data.net.toFixed(2)} net)`;
                resultEl.classList.add('partial');
                playSound('lose');
            }

            updateBalance(data.balance);

            // Reset
            await new Promise(r => setTimeout(r, 1500));
            ball.style.opacity = '0';
            slots.forEach(s => s.classList.remove('winner'));

            setTimeout(() => {
                ball.style.left = '50%';
                ball.style.top = '10px';
            }, 300);

        } catch (error) {
            resultEl.textContent = '‚ùå ' + error.message;
            resultEl.classList.add('error');
            playSound('error');
        }

        isDropping = false;
        dropBtn.disabled = false;
        dropBtn.textContent = '‚ö™ DROP';
    }

    // Initialize on load
    initBoard();
</script>
{% endblock %}